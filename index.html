<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Workout Detector (Portrait, Fit Camera)</title>

    <style>
      :root { color-scheme: dark; }

      body{
        margin:0;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
        background:#0b0f14;
        color:#e9eef5;
      }

      .wrap{min-height:100vh;display:grid;grid-template-rows:auto 1fr;}

      header{
        padding:12px 14px;
        border-bottom:1px solid rgba(255,255,255,.08);
        background:rgba(255,255,255,.03);
        backdrop-filter:blur(10px);
        display:grid;
        gap:10px;
      }

      .topRow{
        display:flex;
        align-items:flex-start;
        justify-content:space-between;
        gap:12px;
      }

      .left{display:grid;gap:4px;min-width:0;}
      .title{font-weight:700;font-size:14px;}
      .subtitle{opacity:.8;font-size:12px;}

      .pills{display:flex;gap:8px;flex-wrap:wrap;}
      .pill{
        padding:8px 10px;
        border-radius:999px;
        border:1px solid rgba(255,255,255,.12);
        background:rgba(255,255,255,.04);
        font-size:12px;
        opacity:.9;
        white-space:nowrap;
      }

      /* 3 lines of controls */
      .controls{
        display:grid;
        gap:8px;
        justify-items:end;
        align-content:start;
      }
      .toggleGroup{
        display:flex;
        gap:8px;
        flex-wrap:wrap;
        justify-content:flex-end;
      }

      button{
        border:1px solid rgba(255,255,255,.16);
        background:rgba(255,255,255,.06);
        color:#e9eef5;
        padding:10px 12px;
        border-radius:10px;
        cursor:pointer;
        font-weight:600;
        -webkit-tap-highlight-color: transparent;
      }
      button:disabled{opacity:.5;cursor:not-allowed;}
      .toggleGroup button.active{
        border-color:rgba(0,255,140,.35);
        background:rgba(0,180,90,.18);
      }

      main{display:grid;place-items:center;padding:14px;}

      .stage{
        position:relative;
        height:min(78vh, 860px);
        aspect-ratio:9/16;
        width:auto;
        max-width:96vw;

        border-radius:16px;
        overflow:hidden;
        border:1px solid rgba(255,255,255,.10);
        background:#000;
        touch-action: manipulation;
      }

      video{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        object-fit:contain;  /* show full frame */
        transform:scaleX(-1);
        z-index:1;
      }

      canvas{
        position:absolute;
        inset:0;
        width:100%;
        height:100%;
        object-fit:contain;
        background:transparent;
        transform:scaleX(-1);
        pointer-events:none;
        z-index:2;
      }

      .hud{
        position:absolute;
        left:12px;
        top:12px;
        display:grid;
        gap:8px;
        z-index:3;
      }
      .badge{
        padding:8px 10px;
        border-radius:12px;
        background:rgba(0,0,0,.45);
        border:1px solid rgba(255,255,255,.10);
        font-size:12px;
        line-height:1.25;
        max-width:min(78vw, 420px);
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }

      .check{
        position:absolute;
        right:14px;
        top:14px;
        z-index:4;
        width:70px;
        height:70px;
        border-radius:18px;
        display:grid;
        place-items:center;
        background:rgba(0,180,90,.18);
        border:1px solid rgba(0,255,140,.35);
        opacity:0;
        transform:scale(.92);
        transition:opacity 160ms ease,transform 160ms ease;
        backdrop-filter:blur(8px);
        pointer-events:none;
      }
      .check.show{opacity:1;transform:scale(1);}
      .check svg{width:42px;height:42px;}

      .error{
        position:absolute;
        inset:0;
        display:grid;
        place-items:center;
        padding:18px;
        text-align:center;
        background:rgba(0,0,0,.65);
        z-index:10;
      }
      .error .box{
        max-width:560px;
        padding:14px;
        border-radius:14px;
        border:1px solid rgba(255,255,255,.12);
        background:rgba(20,24,32,.88);
      }
      .error .box h2{margin:0 0 8px;font-size:16px;}
      .error .box p{margin:0;opacity:.88;font-size:13px;line-height:1.4;white-space:pre-wrap;}
      .hidden{display:none;}
    </style>
  </head>

  <body>
    <div class="wrap">
      <header>
        <div class="topRow">
          <div class="left">
            <div class="title">Workout Detector</div>
            <div class="subtitle" id="subtitle">
              Push-ups: side/profile view works best. Jumping jacks: full body in frame.
            </div>
            <div class="pills">
              <div class="pill" id="statusPill">Model: loading…</div>
              <div class="pill" id="modePill">Mode: Push-ups</div>
              <div class="pill" id="fpsPill">Inference: — fps</div>
            </div>
          </div>

          <div class="controls">
            <div class="toggleGroup" aria-label="Mode selection">
              <button id="pushupModeBtn" class="active" disabled>Push-ups</button>
              <button id="jackModeBtn" disabled>Jumping jacks</button>
            </div>
            <button id="startBtn" disabled>Enable camera</button>
            <button id="resetBtn" disabled>Reset</button>
          </div>
        </div>
      </header>

      <main>
        <div class="stage">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>

          <div class="hud">
            <div class="badge" id="hud1">Reps: 0</div>
            <div class="badge" id="hud2">Metric: — | Phase: —</div>
            <div class="badge" id="hud3">Gate: —</div>
          </div>

          <div class="check" id="checkmark" aria-label="Rep detected">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M20 7L10.5 16.5L4 10"
                stroke="rgba(235,255,245,0.95)"
                stroke-width="3"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </div>

          <div class="error hidden" id="errorPane">
            <div class="box">
              <h2>Could not start</h2>
              <p id="errorText"></p>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script type="module">
      import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

      // Try FULL first (better at distance), fallback to LITE.
      const MODEL_URLS = [
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task",
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
      ];
      const WASM_ROOT = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm";

      const statusPill = document.getElementById("statusPill");
      const modePill = document.getElementById("modePill");
      const fpsPill = document.getElementById("fpsPill");
      const subtitle = document.getElementById("subtitle");

      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const pushupModeBtn = document.getElementById("pushupModeBtn");
      const jackModeBtn = document.getElementById("jackModeBtn");

      const errorPane = document.getElementById("errorPane");
      const errorText = document.getElementById("errorText");

      const video = document.getElementById("video");
      const canvas = document.getElementById("overlay");
      const ctx = canvas.getContext("2d", { alpha: true });

      const hud1 = document.getElementById("hud1");
      const hud2 = document.getElementById("hud2");
      const hud3 = document.getElementById("hud3");

      const checkmark = document.getElementById("checkmark");

      /** -------------------- Mode -------------------- **/
      const Mode = Object.freeze({ PUSHUPS: "pushups", JACKS: "jacks" });
      let mode = Mode.PUSHUPS;

      function setMode(nextMode) {
        mode = nextMode;
        pushupModeBtn.classList.toggle("active", mode === Mode.PUSHUPS);
        jackModeBtn.classList.toggle("active", mode === Mode.JACKS);

        modePill.textContent = `Mode: ${mode === Mode.PUSHUPS ? "Push-ups" : "Jumping jacks"}`;
        subtitle.textContent =
          mode === Mode.PUSHUPS
            ? "Push-ups: side/profile view works best."
            : "Jumping jacks: stand back so your full body is visible. Good lighting helps.";

        reset(true);
      }

      /** -------------------- Performance -------------------- **/
      const TARGET_INFER_FPS = 15;
      const MIN_INFER_MS = 1000 / TARGET_INFER_FPS;

      /** -------------------- Tuning -------------------- **/
      // Your error "low LShoulder" happens when you're far away -> confidence drops.
      // So: (1) lower jack confidence requirement, (2) don't require LEFT shoulder specifically.
      const CONF_MIN_PUSHUP = 0.45;
      const CONF_MIN_JACK = 0.12; // tolerant for full-body far shots

      const SHOW_CHECK_MS = 700;

      // Push-ups (tolerant)
      const PUSHUP_DOWN_ANGLE = 110;
      const PUSHUP_UP_ANGLE = 160;
      const PUSHUP_MAX_SHOULDER_HIP_Y_DIFF = 0.30;
      const PUSHUP_MAX_HIP_ANKLE_Y_DIFF = 0.45;
      const PUSHUP_MIN_WRIST_BELOW_SHOULDER = 0.02;

      // Jumping jacks thresholds (more forgiving)
      const JACK_OPEN_ARMS_RATIO = 1.18;
      const JACK_CLOSED_ARMS_RATIO = 1.05;

      const JACK_OPEN_LEGS_RATIO = 1.18;
      const JACK_CLOSED_LEGS_RATIO = 1.06;

      // Arms-up check: use shoulders if available; else use nose as reference.
      const JACK_ARMS_UP_OPEN = 0.010;
      const JACK_ARMS_UP_CLOSED = 0.004;

      const JACK_EMA_ALPHA = 0.35;

      /** -------------------- State -------------------- **/
      let poseLandmarker = null;
      let drawingUtils = null;

      let stream = null;
      let webcamRunning = false;
      let rafId = null;

      let repCount = 0;
      let phase = "unknown";
      let lastMetric = null;

      // Jack smoothing state
      let jackArmsRatioEma = null;
      let jackLegsRatioEma = null;
      let jackArmsUpEma = null;

      let checkTimer = null;

      let lastInferAt = 0;
      let inferCount = 0;
      let fpsWindowStart = performance.now();

      function showError(message) {
        errorText.textContent = message;
        errorPane.classList.remove("hidden");
      }
      function hideError() {
        errorPane.classList.add("hidden");
        errorText.textContent = "";
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
      function hypot2(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

      function lmConf(lm) {
        const v = (typeof lm.visibility === "number") ? lm.visibility : lm.presence;
        return (typeof v === "number") ? v : 0;
      }
      function c(landmarks, idx) { return lmConf(landmarks[idx]); }

      function angleDeg(a, b, cpt) {
        const abx = a.x - b.x, aby = a.y - b.y;
        const cbx = cpt.x - b.x, cby = cpt.y - b.y;
        const dot = abx * cbx + aby * cby;
        const ab = Math.hypot(abx, aby);
        const cb = Math.hypot(cbx, cby);
        if (ab < 1e-6 || cb < 1e-6) return null;
        const cos = clamp(dot / (ab * cb), -1, 1);
        return Math.acos(cos) * (180 / Math.PI);
      }

      function ema(prev, next, alpha) {
        return (prev == null) ? next : (prev * (1 - alpha) + next * alpha);
      }

      function flashCheckmark() {
        checkmark.classList.add("show");
        if (checkTimer) clearTimeout(checkTimer);
        checkTimer = setTimeout(() => checkmark.classList.remove("show"), SHOW_CHECK_MS);
      }

      function resizeCanvasToVideo() {
        const w = video.videoWidth || 0;
        const h = video.videoHeight || 0;
        if (!w || !h) return;
        if (canvas.width !== w) canvas.width = w;
        if (canvas.height !== h) canvas.height = h;
      }

      function clearCanvas() {
        if (canvas.width && canvas.height) ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      function drawPose(landmarks) {
        resizeCanvasToVideo();
        clearCanvas();
        drawingUtils.drawLandmarks(landmarks, { radius: 3 });
        drawingUtils.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS);
      }

      function updateHUD({ reps, metricLabel, metricValue, phaseText, gate }) {
        hud1.textContent = `Reps: ${reps}`;
        hud2.textContent = `${metricLabel}: ${metricValue} | Phase: ${phaseText}`;
        hud3.textContent = `Gate: ${gate}`;
      }

      /** -------------------- Push-ups -------------------- **/
      function pickSide(landmarks) {
        const L = [11, 13, 15].map(i => c(landmarks, i));
        const R = [12, 14, 16].map(i => c(landmarks, i));
        const lAvg = (L[0] + L[1] + L[2]) / 3;
        const rAvg = (R[0] + R[1] + R[2]) / 3;
        return (lAvg >= rAvg) ? "left" : "right";
      }

      function getArmPoints(landmarks, side) {
        const idx = (side === "left")
          ? { shoulder: 11, elbow: 13, wrist: 15, hip: 23, ankle: 27 }
          : { shoulder: 12, elbow: 14, wrist: 16, hip: 24, ankle: 28 };

        return {
          shoulder: landmarks[idx.shoulder],
          elbow: landmarks[idx.elbow],
          wrist: landmarks[idx.wrist],
          hip: landmarks[idx.hip],
          ankle: landmarks[idx.ankle],
          conf: {
            shoulder: c(landmarks, idx.shoulder),
            wrist: c(landmarks, idx.wrist),
            hip: c(landmarks, idx.hip),
            ankle: c(landmarks, idx.ankle),
          }
        };
      }

      function pushupGateOk(pts) {
        const confOk =
          pts.conf.shoulder >= CONF_MIN_PUSHUP &&
          pts.conf.wrist >= CONF_MIN_PUSHUP &&
          pts.conf.hip >= CONF_MIN_PUSHUP &&
          pts.conf.ankle >= CONF_MIN_PUSHUP;

        if (!confOk) {
          return { ok: false, reason: `low conf S:${pts.conf.shoulder.toFixed(2)} W:${pts.conf.wrist.toFixed(2)} H:${pts.conf.hip.toFixed(2)} A:${pts.conf.ankle.toFixed(2)}` };
        }

        const wristBelow = (pts.wrist.y - pts.shoulder.y) >= PUSHUP_MIN_WRIST_BELOW_SHOULDER;
        const shHip = Math.abs(pts.shoulder.y - pts.hip.y) <= PUSHUP_MAX_SHOULDER_HIP_Y_DIFF;
        const hipAnk = Math.abs(pts.hip.y - pts.ankle.y) <= PUSHUP_MAX_HIP_ANKLE_Y_DIFF;

        const ok = wristBelow && shHip && hipAnk;
        return { ok, reason: ok ? "ok" : `wristBelow=${wristBelow}, shHip=${shHip}, hipAnk=${hipAnk}` };
      }

      function processPushups(landmarks) {
        const side = pickSide(landmarks);
        const pts = getArmPoints(landmarks, side);
        const gate = pushupGateOk(pts);

        if (!gate.ok) {
          updateHUD({
            reps: repCount,
            metricLabel: "Elbow",
            metricValue: lastMetric == null ? "—" : `${lastMetric.toFixed(0)}°`,
            phaseText: phase,
            gate: gate.reason
          });
          return;
        }

        const a = angleDeg(pts.shoulder, pts.elbow, pts.wrist);
        if (a == null) {
          updateHUD({ reps: repCount, metricLabel: "Elbow", metricValue: "—", phaseText: phase, gate: "bad angle" });
          return;
        }

        if (lastMetric == null) lastMetric = a;
        else lastMetric = 0.65 * lastMetric + 0.35 * a;

        if ((phase === "unknown" || phase === "up") && lastMetric <= PUSHUP_DOWN_ANGLE) {
          phase = "down";
        } else if (phase === "down" && lastMetric >= PUSHUP_UP_ANGLE) {
          phase = "up";
          repCount += 1;
          flashCheckmark();
        } else if (phase === "unknown" && lastMetric >= PUSHUP_UP_ANGLE) {
          phase = "up";
        }

        updateHUD({
          reps: repCount,
          metricLabel: "Elbow",
          metricValue: `${lastMetric.toFixed(0)}°`,
          phaseText: phase,
          gate: "ok"
        });
      }

      /** -------------------- Jumping jacks (fixes “low LShoulder”) -------------------- **/
      function bestPoint(landmarks, indices) {
        let best = { pt: null, conf: -1, idx: -1 };
        for (const i of indices) {
          const conf = c(landmarks, i);
          if (conf > best.conf) best = { pt: landmarks[i], conf, idx: i };
        }
        return best;
      }

      function jackGate(landmarks) {
        // For far/full-body: do NOT require *left* shoulder specifically.
        // Use whichever shoulder is better, and fall back to nose if shoulders are weak.
        const LS = { pt: landmarks[11], conf: c(landmarks, 11) };
        const RS = { pt: landmarks[12], conf: c(landmarks, 12) };
        const LH = { pt: landmarks[23], conf: c(landmarks, 23) };
        const RH = { pt: landmarks[24], conf: c(landmarks, 24) };
        const NO = { pt: landmarks[0],  conf: c(landmarks, 0) };

        const lArm = bestPoint(landmarks, [15, 13]); // wrist or elbow
        const rArm = bestPoint(landmarks, [16, 14]);
        const lLeg = bestPoint(landmarks, [27, 25]); // ankle or knee
        const rLeg = bestPoint(landmarks, [28, 26]);

        const haveHips = (LH.conf >= CONF_MIN_JACK && RH.conf >= CONF_MIN_JACK);
        const haveSomeShoulder = (LS.conf >= CONF_MIN_JACK || RS.conf >= CONF_MIN_JACK);
        const haveNose = (NO.conf >= CONF_MIN_JACK);

        if (!haveHips) return { ok:false, reason:`low hips LH:${LH.conf.toFixed(2)} RH:${RH.conf.toFixed(2)}` };
        if (!haveSomeShoulder && !haveNose) {
          return { ok:false, reason:`low shoulders/nose LS:${LS.conf.toFixed(2)} RS:${RS.conf.toFixed(2)} NO:${NO.conf.toFixed(2)}` };
        }
        if (lArm.conf < CONF_MIN_JACK || rArm.conf < CONF_MIN_JACK) {
          return { ok:false, reason:`low arms L:${lArm.conf.toFixed(2)} R:${rArm.conf.toFixed(2)}` };
        }
        if (lLeg.conf < CONF_MIN_JACK || rLeg.conf < CONF_MIN_JACK) {
          return { ok:false, reason:`low legs L:${lLeg.conf.toFixed(2)} R:${rLeg.conf.toFixed(2)}` };
        }

        return { ok:true, LS, RS, LH, RH, NO, lArm, rArm, lLeg, rLeg };
      }

      function processJumpingJacks(landmarks) {
        const g = jackGate(landmarks);
        if (!g.ok) {
          updateHUD({
            reps: repCount,
            metricLabel: "Jacks",
            metricValue: lastMetric == null ? "—" : lastMetric,
            phaseText: phase,
            gate: g.reason
          });
          return;
        }

        // Baselines
        const hipWidth = hypot2(g.LH.pt.x, g.LH.pt.y, g.RH.pt.x, g.RH.pt.y);

        // Shoulder width if both shoulders are decent, else use hipWidth.
        let baseArms = hipWidth;
        if (g.LS.conf >= CONF_MIN_JACK && g.RS.conf >= CONF_MIN_JACK) {
          const shoulderWidth = hypot2(g.LS.pt.x, g.LS.pt.y, g.RS.pt.x, g.RS.pt.y);
          baseArms = Math.max(shoulderWidth, 0.08);
        } else {
          baseArms = Math.max(hipWidth, 0.08);
        }

        const baseLegs = Math.max(hipWidth, 0.08);

        // Distances (use wrist or elbow / ankle or knee based on best confidence)
        const armDist = hypot2(g.lArm.pt.x, g.lArm.pt.y, g.rArm.pt.x, g.rArm.pt.y);
        const legDist = hypot2(g.lLeg.pt.x, g.lLeg.pt.y, g.rLeg.pt.x, g.rLeg.pt.y);

        const armsRatio = armDist / baseArms;
        const legsRatio = legDist / baseLegs;

        // Reference Y for “arms up”:
        // Prefer best shoulder; fallback to nose.
        let refY = null;
        if (g.LS.conf >= g.RS.conf && g.LS.conf >= CONF_MIN_JACK) refY = g.LS.pt.y;
        else if (g.RS.conf >= CONF_MIN_JACK) refY = g.RS.pt.y;
        else refY = g.NO.pt.y; // nose

        const armsY = (g.lArm.pt.y + g.rArm.pt.y) / 2;
        const armsUpDelta = (refY - armsY); // positive when arms are above the reference

        // Smooth for stability
        jackArmsRatioEma = ema(jackArmsRatioEma, armsRatio, JACK_EMA_ALPHA);
        jackLegsRatioEma = ema(jackLegsRatioEma, legsRatio, JACK_EMA_ALPHA);
        jackArmsUpEma = ema(jackArmsUpEma, armsUpDelta, JACK_EMA_ALPHA);

        const openPose =
          jackArmsRatioEma >= JACK_OPEN_ARMS_RATIO &&
          jackLegsRatioEma >= JACK_OPEN_LEGS_RATIO &&
          jackArmsUpEma >= JACK_ARMS_UP_OPEN;

        const closedPose =
          jackArmsRatioEma <= JACK_CLOSED_ARMS_RATIO &&
          jackLegsRatioEma <= JACK_CLOSED_LEGS_RATIO &&
          jackArmsUpEma <= JACK_ARMS_UP_CLOSED;

        lastMetric =
          `A:${jackArmsRatioEma.toFixed(2)} L:${jackLegsRatioEma.toFixed(2)} Up:${jackArmsUpEma.toFixed(3)} ` +
          `| LS:${g.LS.conf.toFixed(2)} RS:${g.RS.conf.toFixed(2)} NO:${g.NO.conf.toFixed(2)}`;

        // closed -> open -> closed counts
        if (phase === "unknown") {
          phase = closedPose ? "closed" : (openPose ? "open" : "unknown");
        } else if (phase === "closed") {
          if (openPose) phase = "open";
        } else if (phase === "open") {
          if (closedPose) {
            phase = "closed";
            repCount += 1;
            flashCheckmark();
          }
        }

        updateHUD({
          reps: repCount,
          metricLabel: "Jacks",
          metricValue: lastMetric,
          phaseText: phase,
          gate: openPose ? "openPose" : (closedPose ? "closedPose" : "between")
        });
      }

      function processPoseByMode(landmarks) {
        if (mode === Mode.PUSHUPS) processPushups(landmarks);
        else processJumpingJacks(landmarks);
      }

      /** -------------------- Loop -------------------- **/
      function updateFps(now) {
        inferCount++;
        const elapsed = now - fpsWindowStart;
        if (elapsed >= 1000) {
          fpsPill.textContent = `Inference: ${(inferCount / (elapsed / 1000)).toFixed(1)} fps`;
          fpsWindowStart = now;
          inferCount = 0;
        }
      }

      function loop(now) {
        if (!webcamRunning) return;

        if (now - lastInferAt >= MIN_INFER_MS && video.readyState >= 2) {
          lastInferAt = now;

          poseLandmarker.detectForVideo(video, now, (result) => {
            if (!result?.landmarks?.length) {
              clearCanvas();
              updateHUD({
                reps: repCount,
                metricLabel: mode === Mode.PUSHUPS ? "Elbow" : "Jacks",
                metricValue: "—",
                phaseText: phase,
                gate: "no pose"
              });
              return;
            }

            const person = result.landmarks[0];
            drawPose(person);
            processPoseByMode(person);
          });

          updateFps(now);
        }

        rafId = requestAnimationFrame(loop);
      }

      /** -------------------- Model + Camera -------------------- **/
      async function createLandmarker(vision, modelUrl, delegate) {
        return PoseLandmarker.createFromOptions(vision, {
          baseOptions: { modelAssetPath: modelUrl, delegate },
          runningMode: "VIDEO",
          numPoses: 1,
          // Loosen these a bit for full-body at distance:
          minPoseDetectionConfidence: 0.35,
          minPosePresenceConfidence: 0.35,
          minTrackingConfidence: 0.35,
        });
      }

      async function initModel() {
        statusPill.textContent = "Model: loading…";
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");

        let lastErr = null;

        for (const url of MODEL_URLS) {
          // Try GPU, then CPU
          try {
            poseLandmarker = await createLandmarker(vision, url, "GPU");
            statusPill.textContent = `Model: ready (GPU)`;
            drawingUtils = new DrawingUtils(ctx);
            return;
          } catch (e) {
            lastErr = e;
          }

          try {
            poseLandmarker = await createLandmarker(vision, url, "CPU");
            statusPill.textContent = `Model: ready (CPU)`;
            drawingUtils = new DrawingUtils(ctx);
            return;
          } catch (e) {
            lastErr = e;
          }
        }

        throw lastErr || new Error("Failed to load pose model.");
      }

      async function startCamera() {
        hideError();

        const constraints = {
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30, max: 30 }
          },
          audio: false
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        await new Promise((resolve) => { video.onloadedmetadata = () => resolve(); });
        try { await video.play(); } catch {}

        webcamRunning = true;
        resetBtn.disabled = false;
        startBtn.textContent = "Stop camera";

        lastInferAt = 0;
        fpsWindowStart = performance.now();
        inferCount = 0;
        fpsPill.textContent = "Inference: — fps";

        resizeCanvasToVideo();
        clearCanvas();

        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(loop);
      }

      function stopCamera() {
        webcamRunning = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;

        if (stream) {
          for (const t of stream.getTracks()) t.stop();
          stream = null;
        }
        video.srcObject = null;

        clearCanvas();
        startBtn.textContent = "Enable camera";
        resetBtn.disabled = true;
        fpsPill.textContent = "Inference: — fps";
      }

      function reset(resetJackFilters = false) {
        repCount = 0;
        phase = "unknown";
        lastMetric = null;
        checkmark.classList.remove("show");

        if (resetJackFilters) {
          jackArmsRatioEma = null;
          jackLegsRatioEma = null;
          jackArmsUpEma = null;
        }

        updateHUD({
          reps: repCount,
          metricLabel: mode === Mode.PUSHUPS ? "Elbow" : "Jacks",
          metricValue: "—",
          phaseText: "—",
          gate: "—"
        });
      }

      startBtn.addEventListener("click", async () => {
        try {
          if (webcamRunning) stopCamera();
          else await startCamera();
        } catch (e) {
          stopCamera();
          showError(
            String(e?.message || e) +
            "\n\nFixes:\n• Use https or http://localhost\n• Allow camera permission\n• Close other tabs using the camera\n• Improve lighting / move closer"
          );
        }
      });

      resetBtn.addEventListener("click", () => reset(true));
      pushupModeBtn.addEventListener("click", () => setMode(Mode.PUSHUPS));
      jackModeBtn.addEventListener("click", () => setMode(Mode.JACKS));

      document.addEventListener("visibilitychange", () => {
        if (document.hidden && webcamRunning) stopCamera();
      });

      (async () => {
        try {
          if (!navigator.mediaDevices?.getUserMedia) {
            statusPill.textContent = "Model: unavailable";
            showError("This browser does not support camera access (getUserMedia).");
            return;
          }
          await initModel();
          startBtn.disabled = false;
          pushupModeBtn.disabled = false;
          jackModeBtn.disabled = false;

          setMode(Mode.PUSHUPS);
          reset(true);
        } catch (e) {
          statusPill.textContent = "Model: failed";
          showError(String(e?.message || e));
        }
      })();
    </script>
  </body>
</html>
