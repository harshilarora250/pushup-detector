<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Jumping Jacks Counter</title>

    <style>
      :root { color-scheme: dark; }
      body{
        margin:0;
        font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
        background:#000;
        color:#e9eef5;
        overflow:hidden;
      }
      
      .stage{
        position:fixed;
        inset:0;
        width:100vw;
        height:100vh;
        background:#000;
        touch-action: manipulation;
      }
      
      video{
        position:absolute; inset:0;
        width:100%; height:100%;
        object-fit:contain;
        transform:scaleX(-1);
        z-index:1;
      }
      canvas{
        position:absolute; inset:0;
        width:100%; height:100%;
        object-fit:contain;
        background:transparent;
        transform:scaleX(-1);
        pointer-events:none;
        z-index:2;
      }

      /* Overlay controls - top right, 3 buttons stacked */
      .overlayControls{
        position:absolute;
        right:14px;
        top:14px;
        display:grid;
        gap:8px;
        z-index:5;
      }
      .overlayControls button{
        border:1px solid rgba(255,255,255,.2);
        background:rgba(0,0,0,.6);
        backdrop-filter:blur(10px);
        color:#e9eef5;
        padding:10px 14px;
        border-radius:10px;
        cursor:pointer;
        font-weight:600;
        font-size:13px;
        white-space:nowrap;
        -webkit-tap-highlight-color: transparent;
        transition:background 150ms ease;
      }
      .overlayControls button:hover{
        background:rgba(0,0,0,.75);
      }
      .overlayControls button:disabled{
        opacity:.5;
        cursor:not-allowed;
      }
      .overlayControls button.active{
        border-color:rgba(0,255,140,.4);
        background:rgba(0,180,90,.25);
      }

      .hud{
        position:absolute; left:12px; top:12px;
        display:grid; gap:8px;
        z-index:3;
      }
      .badge{
        padding:8px 10px;
        border-radius:12px;
        background:rgba(0,0,0,.6);
        backdrop-filter:blur(10px);
        border:1px solid rgba(255,255,255,.15);
        font-size:12px;
        line-height:1.25;
        max-width:min(78vw, 520px);
        overflow:hidden;
        text-overflow:ellipsis;
        white-space:nowrap;
      }

      /* Big rep counter */
      .bigRep{
        position:absolute;
        left:50%;
        bottom:14px;
        transform:translateX(-50%);
        z-index:4;
        padding:10px 14px;
        border-radius:14px;
        background:rgba(0,0,0,.6);
        backdrop-filter:blur(10px);
        border:1px solid rgba(255,255,255,.15);
        font-weight:800;
        font-size:28px;
        letter-spacing:0.5px;
        min-width:80px;
        text-align:center;
      }

      .check{
        position:absolute; 
        left:50%;
        top:50%;
        transform:translate(-50%, -50%) scale(.92);
        z-index:6;
        width:90px; 
        height:90px;
        border-radius:20px;
        display:grid; 
        place-items:center;
        background:rgba(0,180,90,.25);
        border:2px solid rgba(0,255,140,.5);
        opacity:0;
        transition:opacity 160ms ease,transform 160ms ease;
        backdrop-filter:blur(12px);
        pointer-events:none;
      }
      .check.show{opacity:1;transform:translate(-50%, -50%) scale(1);}
      .check svg{width:50px;height:50px;}

      .error{
        position:absolute; inset:0;
        display:grid; place-items:center;
        padding:18px; text-align:center;
        background:rgba(0,0,0,.85);
        backdrop-filter:blur(10px);
        z-index:10;
      }
      .error .box{
        max-width:560px;
        padding:16px 18px;
        border-radius:14px;
        border:1px solid rgba(255,255,255,.2);
        background:rgba(20,24,32,.95);
      }
      .error .box h2{margin:0 0 8px;font-size:16px;}
      .error .box p{margin:0;opacity:.88;font-size:13px;line-height:1.4;white-space:pre-wrap;}
      .hidden{display:none;}
    </style>
  </head>

  <body>
    <div class="stage">
      <video id="video" autoplay playsinline muted></video>
      <canvas id="overlay"></canvas>

      <!-- Overlay controls - top right, 3 buttons -->
      <div class="overlayControls">
        <button id="startBtn" disabled>Enable camera</button>
        <button id="resetBtn" disabled>Reset</button>
        <button id="jackModeBtn" class="active" disabled>Jumping jacks</button>
      </div>

      <div class="hud">
        <div class="badge" id="hud1">Reps: 0</div>
        <div class="badge" id="hud2">Metric: — | Phase: —</div>
        <div class="badge" id="hud3">Gate: —</div>
      </div>

      <div class="bigRep" id="bigRep">0</div>

      <div class="check" id="checkmark" aria-label="Rep detected">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path
            d="M20 7L10.5 16.5L4 10"
            stroke="rgba(235,255,245,0.95)"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </div>

      <div class="error hidden" id="errorPane">
        <div class="box">
          <h2>Could not start</h2>
          <p id="errorText"></p>
        </div>
      </div>
    </div>

    <script type="module">
      import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

      const MODEL_URLS = [
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task",
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task",
      ];
      const WASM_ROOT = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm";

      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const jackModeBtn = document.getElementById("jackModeBtn");

      const errorPane = document.getElementById("errorPane");
      const errorText = document.getElementById("errorText");

      const video = document.getElementById("video");
      const canvas = document.getElementById("overlay");
      const ctx = canvas.getContext("2d", { alpha: true });

      const hud1 = document.getElementById("hud1");
      const hud2 = document.getElementById("hud2");
      const hud3 = document.getElementById("hud3");
      const bigRep = document.getElementById("bigRep");

      const checkmark = document.getElementById("checkmark");

      const TARGET_INFER_FPS = 24;
      const MIN_INFER_MS = 1000 / TARGET_INFER_FPS;
      const SHOW_CHECK_MS = 650;

      // Jumping jack detection
      const EMA_ALPHA = 0.55;
      const JACK_OPEN_LEGS_RATIO = 1.22;
      const JACK_CLOSED_LEGS_RATIO = 1.10;
      const JACK_UP_OPEN = 0.035;
      const JACK_UP_CLOSED = 0.015;
      const JACK_REP_COOLDOWN_MS = 320;
      const JACK_OPEN_STREAK_FRAMES = 2;

      let poseLandmarker = null;
      let drawingUtils = null;
      let stream = null;
      let webcamRunning = false;
      let rafId = null;

      let repCount = 0;
      let phase = "unknown";
      let lastMetric = null;

      let legsRatioEma = null;
      let upEma = null;

      let openFrames = 0;
      let notOpenFrames = 0;
      let openLatched = false;
      let lastRepAt = 0;

      let checkTimer = null;
      let lastInferAt = 0;

      function showError(message) {
        errorText.textContent = message;
        errorPane.classList.remove("hidden");
      }
      function hideError() {
        errorPane.classList.add("hidden");
        errorText.textContent = "";
      }

      function hypot2(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }
      function ema(prev, next, alpha) { return (prev == null) ? next : (prev * (1 - alpha) + next * alpha); }

      function flashCheckmark() {
        checkmark.classList.add("show");
        if (checkTimer) clearTimeout(checkTimer);
        checkTimer = setTimeout(() => checkmark.classList.remove("show"), SHOW_CHECK_MS);
      }

      function resizeCanvasToVideo() {
        const w = video.videoWidth || 0;
        const h = video.videoHeight || 0;
        if (!w || !h) return;
        if (canvas.width !== w) canvas.width = w;
        if (canvas.height !== h) canvas.height = h;
      }
      function clearCanvas() {
        if (canvas.width && canvas.height) ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
      function drawPose(landmarks) {
        resizeCanvasToVideo();
        clearCanvas();
        drawingUtils.drawLandmarks(landmarks, { radius: 3 });
        drawingUtils.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS);
      }

      function updateHUD({ reps, metricLabel, metricValue, phaseText, gate }) {
        hud1.textContent = `Reps: ${reps}`;
        bigRep.textContent = String(reps);
        hud2.textContent = `${metricLabel}: ${metricValue} | Phase: ${phaseText}`;
        hud3.textContent = `Gate: ${gate}`;
      }

      function validPoint(p) {
        return p && Number.isFinite(p.x) && Number.isFinite(p.y);
      }

      function bestOf(landmarks, indices) {
        for (const i of indices) {
          const p = landmarks[i];
          if (validPoint(p)) return p;
        }
        return null;
      }

      function processJumpingJacks(landmarks) {
        const lArm = bestOf(landmarks, [15, 13]);
        const rArm = bestOf(landmarks, [16, 14]);
        const lLeg = bestOf(landmarks, [27, 25]);
        const rLeg = bestOf(landmarks, [28, 26]);

        const lHip = landmarks[23];
        const rHip = landmarks[24];
        const lShoulder = landmarks[11];
        const rShoulder = landmarks[12];
        const nose = landmarks[0];

        if (!lArm || !rArm || !lLeg || !rLeg) {
          updateHUD({
            reps: repCount,
            metricLabel: "Jacks",
            metricValue: lastMetric ?? "—",
            phaseText: phase,
            gate: "need arms+legs in frame"
          });
          return;
        }

        let base = null;
        if (validPoint(lHip) && validPoint(rHip)) base = hypot2(lHip.x, lHip.y, rHip.x, rHip.y);
        else if (validPoint(lShoulder) && validPoint(rShoulder)) base = hypot2(lShoulder.x, lShoulder.y, rShoulder.x, rShoulder.y);
        base = Math.max(base ?? 0.25, 0.10);

        const legDist = hypot2(lLeg.x, lLeg.y, rLeg.x, rLeg.y);
        const legsRatio = legDist / base;

        let refY = null;
        if (validPoint(nose)) refY = nose.y;
        if (validPoint(lShoulder)) refY = (refY == null) ? lShoulder.y : Math.min(refY, lShoulder.y);
        if (validPoint(rShoulder)) refY = (refY == null) ? rShoulder.y : Math.min(refY, rShoulder.y);
        if (refY == null) refY = 0.4;

        const armsY = (lArm.y + rArm.y) / 2;
        const up = (refY - armsY);

        legsRatioEma = ema(legsRatioEma, legsRatio, EMA_ALPHA);
        upEma = ema(upEma, up, EMA_ALPHA);

        const openPose = (legsRatioEma >= JACK_OPEN_LEGS_RATIO) && (upEma >= JACK_UP_OPEN);
        const closedPose = (legsRatioEma <= JACK_CLOSED_LEGS_RATIO) && (upEma <= JACK_UP_CLOSED);

        lastMetric = `L:${legsRatioEma.toFixed(2)} Up:${upEma.toFixed(3)} (base:${base.toFixed(2)})`;

        if (openPose) {
          openFrames++;
          notOpenFrames = 0;
        } else {
          notOpenFrames++;
          openFrames = 0;
          if (notOpenFrames >= 2) openLatched = false;
        }

        const now = performance.now();
        if (openFrames >= JACK_OPEN_STREAK_FRAMES && !openLatched && (now - lastRepAt) >= JACK_REP_COOLDOWN_MS) {
          repCount++;
          lastRepAt = now;
          openLatched = true;
          flashCheckmark();
        }

        if (openPose) phase = "open";
        else if (closedPose) phase = "closed";
        else if (phase === "unknown") phase = "between";

        updateHUD({
          reps: repCount,
          metricLabel: "Jacks",
          metricValue: lastMetric,
          phaseText: phase,
          gate: openPose ? "openPose" : (closedPose ? "closedPose" : "between")
        });
      }

      function loop(now) {
        if (!webcamRunning) return;

        if (now - lastInferAt >= MIN_INFER_MS && video.readyState >= 2) {
          lastInferAt = now;

          poseLandmarker.detectForVideo(video, now, (result) => {
            if (!result?.landmarks?.length) {
              clearCanvas();
              updateHUD({
                reps: repCount,
                metricLabel: "Jacks",
                metricValue: "—",
                phaseText: phase,
                gate: "no pose"
              });
              return;
            }

            const person = result.landmarks[0];
            drawPose(person);
            processJumpingJacks(person);
          });
        }

        rafId = requestAnimationFrame(loop);
      }

      async function createLandmarker(vision, modelUrl, delegate) {
        return PoseLandmarker.createFromOptions(vision, {
          baseOptions: { modelAssetPath: modelUrl, delegate },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.35,
          minPosePresenceConfidence: 0.35,
          minTrackingConfidence: 0.35,
        });
      }

      async function initModel() {
        const vision = await FilesetResolver.forVisionTasks(WASM_ROOT);

        let lastErr = null;
        for (const url of MODEL_URLS) {
          try {
            poseLandmarker = await createLandmarker(vision, url, "GPU");
            drawingUtils = new DrawingUtils(ctx);
            return;
          } catch (e) { lastErr = e; }

          try {
            poseLandmarker = await createLandmarker(vision, url, "CPU");
            drawingUtils = new DrawingUtils(ctx);
            return;
          } catch (e) { lastErr = e; }
        }
        throw lastErr || new Error("Failed to load pose model.");
      }

      async function startCamera() {
        hideError();

        const constraints = {
          video: {
            facingMode: "user",
            width: { ideal: 1280 },
            height: { ideal: 720 },
            frameRate: { ideal: 30, max: 30 }
          },
          audio: false
        };

        stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        await new Promise((resolve) => { video.onloadedmetadata = () => resolve(); });
        try { await video.play(); } catch {}

        webcamRunning = true;
        resetBtn.disabled = false;
        startBtn.textContent = "Stop camera";

        lastInferAt = 0;

        resizeCanvasToVideo();
        clearCanvas();

        if (rafId) cancelAnimationFrame(rafId);
        rafId = requestAnimationFrame(loop);
      }

      function stopCamera() {
        webcamRunning = false;
        if (rafId) cancelAnimationFrame(rafId);
        rafId = null;

        if (stream) {
          for (const t of stream.getTracks()) t.stop();
          stream = null;
        }
        video.srcObject = null;

        clearCanvas();
        startBtn.textContent = "Enable camera";
        resetBtn.disabled = true;
      }

      function reset() {
        repCount = 0;
        phase = "unknown";
        lastMetric = null;
        checkmark.classList.remove("show");

        legsRatioEma = null;
        upEma = null;

        openFrames = 0;
        notOpenFrames = 0;
        openLatched = false;
        lastRepAt = 0;

        updateHUD({
          reps: repCount,
          metricLabel: "Jacks",
          metricValue: "—",
          phaseText: "—",
          gate: "—"
        });
      }

      startBtn.addEventListener("click", async () => {
        try {
          if (webcamRunning) stopCamera();
          else await startCamera();
        } catch (e) {
          stopCamera();
          showError(
            String(e?.message || e) +
            "\n\nFixes:\n• Use https or http://localhost\n• Allow camera permission\n• Close other tabs using the camera\n• Improve lighting / move closer"
          );
        }
      });

      resetBtn.addEventListener("click", reset);
      jackModeBtn.addEventListener("click", () => {});

      document.addEventListener("visibilitychange", () => {
        if (document.hidden && webcamRunning) stopCamera();
      });

      (async () => {
        try {
          if (!navigator.mediaDevices?.getUserMedia) {
            showError("This browser does not support camera access (getUserMedia).");
            return;
          }

          await initModel();

          startBtn.disabled = false;
          resetBtn.disabled = false;
          jackModeBtn.disabled = false;

          reset();
        } catch (e) {
          showError(String(e?.message || e));
        }
      })();
    </script>
  </body>
</html>
