<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Workout Detector (Portrait)</title>
    <style>
      :root { color-scheme: dark; }
      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: #0b0f14;
        color: #e9eef5;
      }

      .wrap { min-height: 100vh; display: grid; grid-template-rows: auto 1fr; }

      header {
        padding: 12px 14px;
        border-bottom: 1px solid rgba(255,255,255,0.08);
        background: rgba(255,255,255,0.03);
        backdrop-filter: blur(10px);
        display: grid;
        gap: 10px;
      }

      .topRow {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
      }

      .left {
        display: grid;
        gap: 4px;
      }
      .title { font-weight: 700; font-size: 14px; }
      .subtitle { opacity: 0.8; font-size: 12px; }

      .pills {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
      }
      .pill {
        padding: 8px 10px;
        border-radius: 999px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(255,255,255,0.04);
        font-size: 12px;
        opacity: 0.9;
        white-space: nowrap;
      }

      /* 3 lines of controls */
      .controls {
        display: grid;
        gap: 8px;
        justify-items: end;
      }
      .toggleGroup {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
        flex-wrap: wrap;
      }

      button {
        border: 1px solid rgba(255,255,255,0.16);
        background: rgba(255,255,255,0.06);
        color: #e9eef5;
        padding: 10px 12px;
        border-radius: 10px;
        cursor: pointer;
        font-weight: 600;
      }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      .toggleGroup button.active {
        border-color: rgba(0, 255, 140, 0.35);
        background: rgba(0, 180, 90, 0.18);
      }

      main { display: grid; place-items: center; padding: 14px; }

      /* Portrait stage: height-driven so it fits a phone screen nicely */
/* Stage background (letterbox bars) */
.stage { background: #000; }

/* Video shows full frame without cropping */
video {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  transform: scaleX(-1);
}

/* Canvas stays transparent so video is visible */
canvas {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  background: transparent;     /* IMPORTANT */
  transform: scaleX(-1);
  pointer-events: none;
}



      .hud {
        position: absolute;
        left: 12px;
        top: 12px;
        display: grid;
        gap: 8px;
        z-index: 5;
      }
      .badge {
        padding: 8px 10px;
        border-radius: 12px;
        background: rgba(0,0,0,0.45);
        border: 1px solid rgba(255,255,255,0.10);
        font-size: 12px;
        line-height: 1.25;
      }

      .check {
        position: absolute;
        right: 14px;
        top: 14px;
        z-index: 6;
        width: 70px;
        height: 70px;
        border-radius: 18px;
        display: grid;
        place-items: center;
        background: rgba(0, 180, 90, 0.18);
        border: 1px solid rgba(0, 255, 140, 0.35);
        opacity: 0;
        transform: scale(0.92);
        transition: opacity 160ms ease, transform 160ms ease;
        backdrop-filter: blur(8px);
      }
      .check.show { opacity: 1; transform: scale(1); }
      .check svg { width: 42px; height: 42px; }

      .error {
        position: absolute;
        inset: 0;
        display: grid;
        place-items: center;
        padding: 18px;
        text-align: center;
        background: rgba(0,0,0,0.6);
        z-index: 10;
      }
      .error .box {
        max-width: 560px;
        padding: 14px 14px;
        border-radius: 14px;
        border: 1px solid rgba(255,255,255,0.12);
        background: rgba(20, 24, 32, 0.85);
      }
      .error .box h2 { margin: 0 0 8px; font-size: 16px; }
      .error .box p  { margin: 0; opacity: 0.85; font-size: 13px; line-height: 1.4; }
      .hidden { display: none; }
    </style>
  </head>

  <body>
    <div class="wrap">
      <header>
        <div class="topRow">
          <div class="left">
            <div class="title">Workout Detector</div>
            <div class="subtitle" id="subtitle">
              Push-ups: side/profile view works best. Jumping jacks: full body in frame.
            </div>
            <div class="pills">
              <div class="pill" id="statusPill">Model: loading…</div>
              <div class="pill" id="modePill">Mode: Push-ups</div>
            </div>
          </div>

          <!-- 3 lines: (1) mode buttons, (2) enable camera, (3) reset -->
          <div class="controls">
            <div class="toggleGroup" aria-label="Mode selection">
              <button id="pushupModeBtn" class="active" disabled>Push-ups</button>
              <button id="jackModeBtn" disabled>Jumping jacks</button>
            </div>
            <button id="startBtn" disabled>Enable camera</button>
            <button id="resetBtn" disabled>Reset</button>
          </div>
        </div>
      </header>

      <main>
        <div class="stage">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>

          <div class="hud">
            <div class="badge" id="hud1">Reps: 0</div>
            <div class="badge" id="hud2">Metric: — | Phase: —</div>
            <div class="badge" id="hud3">Gate: —</div>
          </div>

          <div class="check" id="checkmark" aria-label="Rep detected">
            <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path
                d="M20 7L10.5 16.5L4 10"
                stroke="rgba(235,255,245,0.95)"
                stroke-width="3"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </div>

          <div class="error hidden" id="errorPane">
            <div class="box">
              <h2>Could not start</h2>
              <p id="errorText"></p>
            </div>
          </div>
        </div>
      </main>
    </div>

    <script type="module">
      import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

      const MODEL_URL =
        "https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task";
      const WASM_ROOT =
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm";

      const statusPill = document.getElementById("statusPill");
      const modePill = document.getElementById("modePill");
      const subtitle = document.getElementById("subtitle");

      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");
      const pushupModeBtn = document.getElementById("pushupModeBtn");
      const jackModeBtn = document.getElementById("jackModeBtn");

      const errorPane = document.getElementById("errorPane");
      const errorText = document.getElementById("errorText");

      const video = document.getElementById("video");
      const canvas = document.getElementById("overlay");
      const ctx = canvas.getContext("2d");

      const hud1 = document.getElementById("hud1");
      const hud2 = document.getElementById("hud2");
      const hud3 = document.getElementById("hud3");

      const checkmark = document.getElementById("checkmark");

      const Mode = Object.freeze({ PUSHUPS: "pushups", JACKS: "jacks" });
      let mode = Mode.PUSHUPS;

      function setMode(nextMode) {
        mode = nextMode;

        pushupModeBtn.classList.toggle("active", mode === Mode.PUSHUPS);
        jackModeBtn.classList.toggle("active", mode === Mode.JACKS);

        modePill.textContent = `Mode: ${mode === Mode.PUSHUPS ? "Push-ups" : "Jumping jacks"}`;
        subtitle.textContent =
          mode === Mode.PUSHUPS
            ? "Push-ups: side/profile view works best."
            : "Jumping jacks: stand back so your full body is visible.";

        reset();
      }

      /** Shared thresholds **/
      const CONF_MIN = 0.55;
      const SHOW_CHECK_MS = 800;

      /** Push-ups **/
      const PUSHUP_DOWN_ANGLE = 105;
      const PUSHUP_UP_ANGLE = 165;
      const PUSHUP_MAX_SHOULDER_HIP_Y_DIFF = 0.22;
      const PUSHUP_MAX_HIP_ANKLE_Y_DIFF = 0.30;
      const PUSHUP_MIN_WRIST_BELOW_SHOULDER = 0.04;

      /** Jumping jacks **/
      const JACK_ARMS_OPEN_MULT = 1.6;
      const JACK_ARMS_CLOSED_MULT = 1.25;
      const JACK_LEGS_OPEN_MULT = 1.6;
      const JACK_LEGS_CLOSED_MULT = 1.20;
      const JACK_WRISTS_ABOVE_SHOULDERS_MARGIN = 0.06;
      const JACK_WRISTS_NOT_HIGH_MARGIN = 0.02;

      let poseLandmarker = null;
      let drawingUtils = null;

      let webcamRunning = false;
      let lastVideoTime = -1;

      let repCount = 0;
      let phase = "unknown";
      let lastMetric = null;

      let checkTimer = null;

      function showError(message) {
        errorText.textContent = message;
        errorPane.classList.remove("hidden");
      }
      function hideError() {
        errorPane.classList.add("hidden");
        errorText.textContent = "";
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
      function hypot2(ax, ay, bx, by) { return Math.hypot(ax - bx, ay - by); }

      function lmConf(lm) {
        const v = (typeof lm.visibility === "number") ? lm.visibility : lm.presence;
        return (typeof v === "number") ? v : 0;
      }

      function angleDeg(a, b, c) {
        const abx = a.x - b.x, aby = a.y - b.y;
        const cbx = c.x - b.x, cby = c.y - b.y;

        const dot = abx * cbx + aby * cby;
        const ab = Math.hypot(abx, aby);
        const cb = Math.hypot(cbx, cby);
        if (ab < 1e-6 || cb < 1e-6) return null;

        const cos = clamp(dot / (ab * cb), -1, 1);
        return Math.acos(cos) * (180 / Math.PI);
      }

      function flashCheckmark() {
        checkmark.classList.add("show");
        if (checkTimer) clearTimeout(checkTimer);
        checkTimer = setTimeout(() => checkmark.classList.remove("show"), SHOW_CHECK_MS);
      }

      function resizeCanvasToVideo() {
        const w = video.videoWidth || 720;
        const h = video.videoHeight || 1280;
        if (canvas.width !== w) canvas.width = w;
        if (canvas.height !== h) canvas.height = h;
      }

      function drawPose(landmarks) {
        resizeCanvasToVideo();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawingUtils.drawLandmarks(landmarks, { radius: 3 });
        drawingUtils.drawConnectors(landmarks, PoseLandmarker.POSE_CONNECTIONS);
      }

      function updateHUD({ reps, metricLabel, metricValue, phaseText, gate }) {
        hud1.textContent = `Reps: ${reps}`;
        hud2.textContent = `${metricLabel}: ${metricValue} | Phase: ${phaseText}`;
        hud3.textContent = `Gate: ${gate}`;
      }

      /** Push-up logic **/
      function pickSide(landmarks) {
        const L = [11, 13, 15].map(i => lmConf(landmarks[i]));
        const R = [12, 14, 16].map(i => lmConf(landmarks[i]));
        const lAvg = (L[0] + L[1] + L[2]) / 3;
        const rAvg = (R[0] + R[1] + R[2]) / 3;
        return (lAvg >= rAvg) ? "left" : "right";
      }

      function getArmPoints(landmarks, side) {
        const idx = (side === "left")
          ? { shoulder: 11, elbow: 13, wrist: 15, hip: 23, ankle: 27 }
          : { shoulder: 12, elbow: 14, wrist: 16, hip: 24, ankle: 28 };

        return {
          shoulder: landmarks[idx.shoulder],
          elbow: landmarks[idx.elbow],
          wrist: landmarks[idx.wrist],
          hip: landmarks[idx.hip],
          ankle: landmarks[idx.ankle],
        };
      }

      function pushupGateOk(pts) {
        const { shoulder, wrist, hip, ankle } = pts;

        const confOk =
          lmConf(shoulder) >= CONF_MIN &&
          lmConf(wrist) >= CONF_MIN &&
          lmConf(hip) >= CONF_MIN &&
          lmConf(ankle) >= CONF_MIN;

        if (!confOk) return { ok: false, reason: "low landmark confidence" };

        const wristBelow = (wrist.y - shoulder.y) >= PUSHUP_MIN_WRIST_BELOW_SHOULDER;
        const shHip = Math.abs(shoulder.y - hip.y) <= PUSHUP_MAX_SHOULDER_HIP_Y_DIFF;
        const hipAnk = Math.abs(hip.y - ankle.y) <= PUSHUP_MAX_HIP_ANKLE_Y_DIFF;

        const ok = wristBelow && shHip && hipAnk;
        return { ok, reason: ok ? "ok" : `wristBelow=${wristBelow}, shHip=${shHip}, hipAnk=${hipAnk}` };
      }

      function processPushups(landmarks) {
        const side = pickSide(landmarks);
        const pts = getArmPoints(landmarks, side);
        const gate = pushupGateOk(pts);

        if (!gate.ok) {
          updateHUD({
            reps: repCount,
            metricLabel: "Elbow",
            metricValue: lastMetric == null ? "—" : `${lastMetric.toFixed(0)}°`,
            phaseText: phase,
            gate: gate.reason
          });
          return;
        }

        const a = angleDeg(pts.shoulder, pts.elbow, pts.wrist);
        if (a == null) {
          updateHUD({ reps: repCount, metricLabel: "Elbow", metricValue: "—", phaseText: phase, gate: "bad angle" });
          return;
        }

        if (lastMetric == null) lastMetric = a;
        else lastMetric = 0.65 * lastMetric + 0.35 * a;

        if ((phase === "unknown" || phase === "up") && lastMetric <= PUSHUP_DOWN_ANGLE) {
          phase = "down";
        } else if (phase === "down" && lastMetric >= PUSHUP_UP_ANGLE) {
          phase = "up";
          repCount += 1;
          flashCheckmark();
        } else if (phase === "unknown" && lastMetric >= PUSHUP_UP_ANGLE) {
          phase = "up";
        }

        updateHUD({
          reps: repCount,
          metricLabel: "Elbow",
          metricValue: `${lastMetric.toFixed(0)}°`,
          phaseText: phase,
          gate: "ok"
        });
      }

      /** Jumping jacks logic **/
      function jackGateOk(landmarks) {
        const idxs = [11,12,15,16,23,24,27,28];
        for (const i of idxs) {
          if (lmConf(landmarks[i]) < CONF_MIN) return { ok: false, reason: "low landmark confidence" };
        }
        return { ok: true, reason: "ok" };
      }

      function processJumpingJacks(landmarks) {
        const gate = jackGateOk(landmarks);
        if (!gate.ok) {
          updateHUD({
            reps: repCount,
            metricLabel: "Open",
            metricValue: lastMetric == null ? "—" : lastMetric,
            phaseText: phase,
            gate: gate.reason
          });
          return;
        }

        const lShoulder = landmarks[11], rShoulder = landmarks[12];
        const lWrist = landmarks[15], rWrist = landmarks[16];
        const lHip = landmarks[23], rHip = landmarks[24];
        const lAnkle = landmarks[27], rAnkle = landmarks[28];

        const shoulderWidth = hypot2(lShoulder.x, lShoulder.y, rShoulder.x, rShoulder.y);
        const hipWidth = hypot2(lHip.x, lHip.y, rHip.x, rHip.y);

        const wristDist = hypot2(lWrist.x, lWrist.y, rWrist.x, rWrist.y);
        const ankleDist = hypot2(lAnkle.x, lAnkle.y, rAnkle.x, rAnkle.y);

        const shouldersY = (lShoulder.y + rShoulder.y) / 2;
        const wristsY = (lWrist.y + rWrist.y) / 2;

        const armsOpen = wristDist > shoulderWidth * JACK_ARMS_OPEN_MULT;
        const armsClosed = wristDist < shoulderWidth * JACK_ARMS_CLOSED_MULT;

        const legsOpen = ankleDist > hipWidth * JACK_LEGS_OPEN_MULT;
        const legsClosed = ankleDist < hipWidth * JACK_LEGS_CLOSED_MULT;

        const wristsAboveShoulders = wristsY < (shouldersY - JACK_WRISTS_ABOVE_SHOULDERS_MARGIN);
        const wristsNotHigh = wristsY > (shouldersY - JACK_WRISTS_NOT_HIGH_MARGIN);

        const openPose = armsOpen && legsOpen && wristsAboveShoulders;
        const closedPose = armsClosed && legsClosed && wristsNotHigh;

        const armsRatio = (shoulderWidth > 1e-6) ? wristDist / shoulderWidth : 0;
        const legsRatio = (hipWidth > 1e-6) ? ankleDist / hipWidth : 0;
        lastMetric = `A:${armsRatio.toFixed(2)} L:${legsRatio.toFixed(2)}`;

        if (phase === "unknown") {
          phase = closedPose ? "closed" : (openPose ? "open" : "unknown");
        } else if (phase === "closed") {
          if (openPose) phase = "open";
        } else if (phase === "open") {
          if (closedPose) {
            phase = "closed";
            repCount += 1;
            flashCheckmark();
          }
        }

        updateHUD({
          reps: repCount,
          metricLabel: "Open",
          metricValue: lastMetric,
          phaseText: phase,
          gate: openPose ? "openPose" : (closedPose ? "closedPose" : "in-between")
        });
      }

      function processPoseByMode(landmarks) {
        if (mode === Mode.PUSHUPS) processPushups(landmarks);
        else processJumpingJacks(landmarks);
      }

      async function predictLoop() {
        if (!webcamRunning) return;

        if (video.currentTime !== lastVideoTime) {
          lastVideoTime = video.currentTime;

          const now = performance.now();
          poseLandmarker.detectForVideo(video, now, (result) => {
            if (!result?.landmarks?.length) {
              updateHUD({
                reps: repCount,
                metricLabel: mode === Mode.PUSHUPS ? "Elbow" : "Open",
                metricValue: "—",
                phaseText: phase,
                gate: "no pose detected"
              });
              return;
            }

            const person = result.landmarks[0];
            drawPose(person);
            processPoseByMode(person);
          });
        }

        requestAnimationFrame(predictLoop);
      }

      async function initModel() {
        statusPill.textContent = "Model: loading…";
        const vision = await FilesetResolver.forVisionTasks(WASM_ROOT);

        poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
          baseOptions: { modelAssetPath: MODEL_URL, delegate: "GPU" },
          runningMode: "VIDEO",
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5,
        });

        drawingUtils = new DrawingUtils(ctx);
        statusPill.textContent = "Model: ready";
        startBtn.disabled = false;
        pushupModeBtn.disabled = false;
        jackModeBtn.disabled = false;
      }

      async function startCamera() {
        hideError();

        // Portrait-friendly constraints
const constraints = {
  video: {
    facingMode: "user",
    width: { ideal: 1280 },
    height: { ideal: 720 }
    // removed aspectRatio
  },
  audio: false,
};


        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        video.srcObject = stream;

        await new Promise((resolve) => { video.onloadedmetadata = () => resolve(); });

        webcamRunning = true;
        resetBtn.disabled = false;
        startBtn.textContent = "Camera on";
        startBtn.disabled = true;

        lastVideoTime = -1;
        resizeCanvasToVideo();
        predictLoop();
      }

      function reset() {
        repCount = 0;
        phase = "unknown";
        lastMetric = null;
        checkmark.classList.remove("show");

        updateHUD({
          reps: repCount,
          metricLabel: mode === Mode.PUSHUPS ? "Elbow" : "Open",
          metricValue: "—",
          phaseText: "—",
          gate: "—"
        });
      }

      startBtn.addEventListener("click", async () => {
        try {
          await startCamera();
        } catch (e) {
          showError(
            String(e?.message || e) +
              "\n\nCommon fixes:\n• Serve over https or localhost\n• Allow camera permission\n• Close other tabs using the camera"
          );
        }
      });

      resetBtn.addEventListener("click", reset);

      pushupModeBtn.addEventListener("click", () => setMode(Mode.PUSHUPS));
      jackModeBtn.addEventListener("click", () => setMode(Mode.JACKS));

      try {
        if (!navigator.mediaDevices?.getUserMedia) {
          showError("This browser does not support camera access (getUserMedia).");
          statusPill.textContent = "Model: unavailable";
        } else {
          await initModel();
          setMode(Mode.PUSHUPS);
        }
      } catch (e) {
        showError(String(e?.message || e));
        statusPill.textContent = "Model: failed";
      }
    </script>
  </body>
</html>
